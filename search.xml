<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS Method Swizzle的秘密]]></title>
    <url>%2F2018%2F05%2F07%2FiOS-Method-Swizzle%E7%9A%84%E7%A7%98%E5%AF%86%2F</url>
    <content type="text"><![CDATA[什么是Method Swizzling方法交换(Method Swizzling)，顾名思义就是将两个方法的实现交换，即由原来的SEL(A)－IMP(A)、SEL(B)－IMP(B)对应关系变成了SEL(A)－IMP(B)、SEL(B)－IMP(A)，如下图： Method类型Method类型是一个objc_method结构体指针，而结构体objc_method有三个成员，方法交换(Method Swizzling)的本质就是更改两个成员method_types和method_imp runtime.h源码 12345678/// An opaque type that represents a method in a class definition.typedef struct objc_method *Method; // 本质是一个结构体struct objc_method &#123; SEL method_name; // 方法名称 char *method_types; // 参数和返回类型的描述字串 IMP method_imp; // 方法的具体的实现的指针&#125; Method Swizzling 实现方式比如我们有一个控制器ParentViewController继承于UIViewController，子控制器SubViewController继承于ParentViewController。我们想替换SubViewController的viewDidAppear为swizzle_viewDidAppear, 运行后先显示ParentViewController页面，然后点击一个Button按钮，push到SubViewController页面，代码如下：（页面都是通过StoryBoard来构建的，请自行构建，我比较懒，这里就只贴上代码） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@interface ParentViewController : UIViewController@end@implementation ParentViewController- (void)viewDidAppear:(BOOL)animated&#123; NSLog(@"%@ %s (IMP = ParentViewController viewDidAppear)",self, _cmd); [super viewDidAppear:animated];&#125;@end@interface SubViewController : ParentViewController@end@implementation SubViewController+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; // 原方法名和替换方法名 SEL originalSelector = @selector(viewDidAppear:); SEL swizzledSelector = @selector(swizzle_viewDidAppear:); // 原方法结构体和替换方法结构体 Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); // 如果当前类没有原方法的实现IMP，先调用class_addMethod来给原方法添加默认的方法实现IMP BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123;// 添加方法实现IMP成功后，修改替换方法结构体内的方法实现IMP和方法类型编码TypeEncoding class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; // 添加失败，调用交互两个方法的实现 method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;- (void)swizzle_viewDidAppear:(BOOL)animated &#123; NSLog(@"%@ %s (IMP = SubViewController swizzle_viewDidAppear)",self, _cmd); [self swizzle_viewDidAppear:animated];&#125;@end 代码说明： dispatch_once 保证方法替换只被执行一次 为什么要先调用类添加方法class_addMethod，然后判断添加失败后，再调用方法交换实现方法method_exchangeImplementations？ 上面代码中SubViewController是没有Override父类的viewDidAppear。如果我们直接调用method_exchangeImplementations会怎么样？ 在这种情况下，我们试试 1234567891011121314151617+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; // 原方法名和替换方法名 SEL originalSelector = @selector(viewDidAppear:); SEL swizzledSelector = @selector(swizzle_viewDidAppear:); // 原方法结构体和替换方法结构体 Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); // 调用交互两个方法的实现 method_exchangeImplementations(originalMethod, swizzledMethod); &#125;);&#125; 改成上面的代码，然后运行。哎哟，出错了！Let me see see 什么情况 12345678910111213141516171819202122232425262728292018-05-07 21:38:56.615884+0800 TestiOS[3469:385923] &lt;ParentViewController: 0x7f8f38c09aa0&gt; viewDidAppear: (IMP = SubViewController swizzle_viewDidAppear)2018-05-07 21:38:56.616189+0800 TestiOS[3469:385923] -[ParentViewController swizzle_viewDidAppear:]: unrecognized selector sent to instance 0x7f8f38c09aa02018-05-07 21:38:56.621157+0800 TestiOS[3469:385923] *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[ParentViewController swizzle_viewDidAppear:]: unrecognized selector sent to instance 0x7f8f38c09aa0'*** First throw call stack:( 0 CoreFoundation 0x000000010e0fd1e6 __exceptionPreprocess + 294 1 libobjc.A.dylib 0x000000010d792031 objc_exception_throw + 48 2 CoreFoundation 0x000000010e17e784 -[NSObject(NSObject) doesNotRecognizeSelector:] + 132 3 UIKit 0x000000010e7a873b -[UIResponder doesNotRecognizeSelector:] + 295 4 CoreFoundation 0x000000010e07f898 ___forwarding___ + 1432 5 CoreFoundation 0x000000010e07f278 _CF_forwarding_prep_0 + 120 6 TestiOS 0x000000010ce903fb -[SubViewController swizzle_viewDidAppear:] + 75 7 UIKit 0x000000010e723ebf -[UIViewController _setViewAppearState:isAnimating:] + 697 8 UIKit 0x000000010e75ac53 -[UINavigationController viewDidAppear:] + 187 9 UIKit 0x000000010e723ebf -[UIViewController _setViewAppearState:isAnimating:] + 697 10 UIKit 0x000000010e726cfb __64-[UIViewController viewDidMoveToWindow:shouldAppearOrDisappear:]_block_invoke + 42 11 UIKit 0x000000010e72503f -[UIViewController _executeAfterAppearanceBlock] + 78 12 UIKit 0x000000010e58564f _runAfterCACommitDeferredBlocks + 634 13 UIKit 0x000000010e57477e _cleanUpAfterCAFlushAndRunDeferredBlocks + 388 14 UIKit 0x000000010e5942d7 __34-[UIApplication _firstCommitBlock]_block_invoke_2 + 155 15 CoreFoundation 0x000000010e09fb0c __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__ + 12 16 CoreFoundation 0x000000010e0842db __CFRunLoopDoBlocks + 331 17 CoreFoundation 0x000000010e083a84 __CFRunLoopRun + 1284 18 CoreFoundation 0x000000010e08330b CFRunLoopRunSpecific + 635 19 GraphicsServices 0x0000000113267a73 GSEventRunModal + 62 20 UIKit 0x000000010e57a0b7 UIApplicationMain + 159 21 TestiOS 0x000000010ce9047f main + 111 22 libdyld.dylib 0x0000000111b56955 start + 1) 控制台打印ParentViewController找不到swizzle_viewDidAppear方法。 这是为什么呢？ 第一行日志显示，ParentViewController是调用自己的方法viewDidAppear，通过打印_cmd输出为viewDidAppear可知道，但是执行的是SubViewController的swizzle_viewDidAppear的方法实现IMP，在swizzle_viewDidAppear方法实现IMP里又调用了[self swizzle_viewDidAppear:animated]这行代码，但是此时self是ParentViewController实例对象，类方法列表里根本没有swizzle_viewDidAppear方法，所以就导致找不到方法错误。说的我都觉得挺绕口的，千言万语不如一张图来的直观，向下瞅: 现在明白了吧，方法交换（Method Swizzling）在子类没有实现viewDidAppear方法的情况下会交换父类的viewDidAppear的实现IMP，所以在swizzle_viewDidAppear实现IMP中调用swizzle_viewDidAppear方法会触发doesNotRecognizeSelector找不到方法错误 如果我们的子类SubViewController重写Override了父类的viewDidAppear方法会怎么样？我们在SubViewController中重写viewDidAppear方法 123456789101112131415161718192021222324252627+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; // 原方法名和替换方法名 SEL originalSelector = @selector(viewDidAppear:); SEL swizzledSelector = @selector(swizzle_viewDidAppear:); // 原方法结构体和替换方法结构体 Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); // 调用交互两个方法的实现 method_exchangeImplementations(originalMethod, swizzledMethod); &#125;);&#125;- (void)viewDidAppear:(BOOL)animated&#123; NSLog(@"%@ %s (IMP = SubViewController viewDidAppear)",self, _cmd); [super viewDidAppear:animated];&#125;- (void)swizzle_viewDidAppear:(BOOL)animated &#123; NSLog(@"%@ %s (IMP = SubViewController swizzle_viewDidAppear)",self, _cmd); [self swizzle_viewDidAppear:animated];&#125; 改成上面的代码，然后运行。这次竟然成功了 1234562018-05-07 21:41:58.467190+0800 TestiOS[3556:400520] &lt;ParentViewController: 0x7fd5a060b730&gt; viewWillAppear2018-05-07 21:41:58.475185+0800 TestiOS[3556:400520] &lt;ParentViewController: 0x7fd5a060b730&gt; viewDidAppear: (IMP = ParentViewController viewDidAppear)2018-05-07 21:42:08.772307+0800 TestiOS[3556:400520] &lt;SubViewController: 0x7fd5a0405170&gt; viewWillAppear2018-05-07 21:42:09.312426+0800 TestiOS[3556:400520] &lt;SubViewController: 0x7fd5a0405170&gt; viewDidAppear: (IMP = SubViewController swizzle_viewDidAppear)2018-05-07 21:42:09.312643+0800 TestiOS[3556:400520] &lt;SubViewController: 0x7fd5a0405170&gt; swizzle_viewDidAppear: (IMP = SubViewController viewDidAppear)2018-05-07 21:42:09.312792+0800 TestiOS[3556:400520] &lt;SubViewController: 0x7fd5a0405170&gt; viewDidAppear: (IMP = ParentViewController viewDidAppear) 你逗我玩儿呢，怎么子类实现viewDidAppear就好了。那是因为子类在检查到自己有viewDidAppear方法就直接交换自己的viewDidAppear方法实现IMP，直接上图，我不想废话了 这下我们明白了，如果直接调用方法method_exchangeImplementations来交换方法，需要考虑到子类有没有相应的方法，如果没有就要特殊处理，那岂不是太麻烦了。哈哈😁不用你瞎操心，苹果有这个方法class_addMethod来帮助我们解决 我们把直接调用method_exchangeImplementations稍微做点修改 1234567891011121314151617181920212223242526272829+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; // 原方法名和替换方法名 SEL originalSelector = @selector(viewDidAppear:); SEL swizzledSelector = @selector(swizzle_viewDidAppear:); // 原方法结构体和替换方法结构体 Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); // 如果当前类没有原方法的实现IMP，先调用class_addMethod来给原方法添加默认的方法实现IMP BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123;// 添加方法实现IMP成功后，修改替换方法结构体内的方法实现IMP和方法类型编码TypeEncoding class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; // 添加失败，调用交互两个方法的实现 method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125; 这样我们就不用关心子类有没有实现viewDidAppear方法，方法class_addMethod在子类没有实现viewDidAppear方法的时候，为其添加swizzle_viewDidAppear方法实现IMP，原方法swizzle_viewDidAppear指向父类的viewDidAppear方法实现IMP 这就是为什么先要调用class_addMethod方法的原因了，如果子类SubViewController实现了方法viewDidAppear，那么class_addMethod方法会返回NO，意思子类存在viewDidAppear方法实现，就直接走method_exchangeImplementations方法交换 好了，就说到这里吧，有问题请留言 参考： Method Swizzling]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用加密算法探寻]]></title>
    <url>%2F2018%2F04%2F06%2F%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%8E%A2%E5%AF%BB%2F</url>
    <content type="text"><![CDATA[在开发过程中，常常用到各种加密方法和算法，本文总结了几种常用加密方法的原理。 对称加密 原理：加密和解密数据使用同一个密钥，适合对大量数据进行加解密 安全性：关键是密钥的保存方式，加密或是解密的任何一方泄漏密钥，都会导致信息泄漏 代表算法：DES、3DES、Blowfish、IDEA、RC4、RC5、RC6、AES等 对称密码常用的数学运算： 移位和循环移位 移位就是将一段数码按照规定的位数整体性地左移或右移。循环右移就是当右移时，把数码的最后的位移到数码的最前头，循环左移正相反。例如，对十进制数码12345678循环右移1位（十进制位）的结果为81234567，而循环左移1位的结果则为23456781。 置换 就是将数码中的某一位的值根据置换表的规定，用另一位代替。它不像移位操作那样整齐有序，看上去杂乱无章。这正是加密所需,被经常应用。 扩展 就是将一段数码扩展成比原来位数更长的数码。扩展方法有多种,例如,可以用置换的方法，以扩展置换表来规定扩展后的数码每一位的替代值。 压缩 就是将一段数码压缩成比原来位数更短的数码。压缩方法有多种，例如，也可以用置换的方法，以表来规定压缩后的数码每一位的替代值。 异或 这是一种二进制布尔代数运算。异或的数学符号为⊕ ，它的运算法则如下：1⊕1 = 00⊕0 = 01⊕0 = 10⊕1 = 1 也可以简单地理解为，参与异或运算的两数位如相等，则结果为0，不等则为1。 迭代 迭代就是多次重复相同的运算，这在密码算法中经常使用，以使得形成的密文更加难以破解。 非对称加密 原理：非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密 安全性：公钥可以被任何人知道，但是私钥被泄漏就会导致信息泄漏 应用场景：数字签名，私钥拥有者对信息进行加密，接受者使用公钥解密成功，就可以确定发送者的身份 密钥长度：通常是1024，2048等。密钥长度增长一倍，公钥操作所需时间增加约4倍，私钥操作所需时间增加约8倍，公私钥生成时间约增长16倍 加密的明文长度：加密的明文长度不能超过RSA密钥的长度减去11byte，比如密钥长度是1024位的，1024位=1024bit=128byte，128-11=117byte，所以明文长度不能超过117byte，如果长度超过该值将会抛出异常。加密后密文的长度为密钥的长度，如密钥长度为1024bit(128Byte)，最后生成的密文固定为 1024bit(128Byte) 代表算法：DES、3DES、Blowfish、IDEA、RC4、RC5、RC6、AES等 哈希散列算法 原理：采用某种散列函数，输入不同长度的明文，得到相同的长度的密文，明文的微小变化都能引起密文的巨大变化。其实哈希散列算法不算是真正的加密，而是生成对应明文的指纹信息，用来校验数据的完整性。 安全性：不能通过密文反推明文，通常作为数据的完整性校验 应用场景1：生成信息摘要，验证信息的完整性 应用场景2：不用明文存储用户密码，比如使用md5(md5(用户密码)+salt)来存储密码和验证密码，防止攻击者用彩虹表攻击 代表算法：MD2、MD4、MD5、PANAMA、SHA-0、SHA-1、SHA-256、SHA-512等 常用算法对比 名称 密钥长度 运算速度 安全性 资源消耗 加密类型 DES 56位 较快 低 中 对称 3DES 168位 慢 中 高 对称 IDEA 128位 较慢 中 高 对称 AES 128、192、256位 快 高 低 对称 RSA 1024、2048、3072、4096 慢 高 高 非对称 DSA 1024、2048、3072、4096 慢 高 低 非对称 ECC 256 快 高 低 非对称 SHA-1 慢 高 低 散列 MD5 快 中 低 散列 参考： DES加密算法原理 DES算法实例详解 AES对称加密算法扫盲 DES，3DES,AES这三种对称密钥的区别与联系 数字签名算法介绍和区别 HOTP和TOTP算法图解]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>加密</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
