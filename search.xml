<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解Thread线程和Queue队列]]></title>
    <url>%2F2018%2F05%2F09%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Thread%E7%BA%BF%E7%A8%8B%E5%92%8CQueue%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[思考一段代码我们先来看一段代码，猜猜一下代码的的运行结果： 12345678910111213141516171819202122232425// 主队列dispatch_queue_t mainQueue = dispatch_get_main_queue();// 给主队列设置一个标记dispatch_queue_set_specific(mainQueue, "key", "main", NULL);// 定义一个block任务dispatch_block_t log = ^&#123; // 判断是否是主线程 NSLog(@"main thread: %d", [NSThread isMainThread]); // 判断是否是主队列 void *value = dispatch_get_specific("key"); NSLog(@"main queue: %d", value != NULL);&#125;;// 全局队列dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);// 异步加入全局队列里dispatch_async(globalQueue, ^&#123; // 异步加入主队列里 dispatch_async(dispatch_get_main_queue(), log);&#125;);NSLog(@"before dispatch_main");dispatch_main();NSLog(@"after dispatch_main"); 运行结果： 1232018-05-08 15:08:05.557398+0800 TestRunLoop[28206:767410] before dispatch_main2018-05-08 15:08:05.557682+0800 TestRunLoop[28206:767462] main thread: 0 //不是主线程2018-05-08 15:08:05.557814+0800 TestRunLoop[28206:767462] main queue: 1 //是主队列 什么情况？派发给主队列的任务不是在主线程上运行，跟我们平常用的和理解的完全不一样。 不要激动，导致这种原因最关键的是这行代码dispatch_main() ,就是这货让主队列的任务在非主线程运行。 这个方法苹果官方文档这样解释的： 123456789101112131415161718192021/*! * @function dispatch_main * * @abstract * Execute blocks submitted to the main queue. * 执行提交给主队列的任务blocks * * @discussion * This function "parks" the main thread and waits for blocks to be submitted * * to the main queue. This function never returns. * 这个函数会阻塞主线程并且等待提交给主队列的任务blocks完成，这个函数永远不会返回 * * Applications that call NSApplicationMain() or CFRunLoopRun() on the * main thread do not need to call dispatch_main(). * */API_AVAILABLE(macos(10.6), ios(4.0))DISPATCH_EXPORT DISPATCH_NOTHROW DISPATCH_NORETURNvoiddispatch_main(void); 意思是这个方法会阻塞主线程，然后在其它线程中执行主队列中的任务，这个方法永远不会返回（意思会卡住主线程） 如果去掉dispatch_main()这行代码，就会正常在主线程里执行任务 122018-05-08 15:20:16.358742+0800 TestRunLoop[28367:779939] main thread: 1 //主线程2018-05-08 15:20:16.359066+0800 TestRunLoop[28367:779939] main queue: 1 //主队列 所以在主队列的任务通常是在主线程里执行，但是不一定，我们可以主动去执行被添加到主队列MainQueue的任务task（也就是说我们可以主动来调用添加到主线程队列的blocks）。可以使用以下任一个来实现：dispatch_main()、UIApplicationMain() 、CFRunLoopRun() 那我们再思考一下，主线程是否可以运行非主队列的任务blocks吗？答案是可以的，比如下面的代码： 12345678// 同步加入全局队列里dispatch_sync(globalQueue, ^&#123; // 判断是否是主线程 NSLog(@"main thread: %d", [NSThread isMainThread]); // 判断是否是主队列 void *value = dispatch_get_specific("key"); NSLog(@"main queue: %d", value != NULL);&#125;); 执行结果： 122018-05-08 15:27:31.215279+0800 TestRunLoop[28442:785851] main thread: 1 // 主线程2018-05-08 15:27:33.519456+0800 TestRunLoop[28442:785851] main queue: 0 // 全局队列 所以通过dispatch_sync()执行的block不会开辟新的线程，而是在当前的线程（即主线程）中同步执行block runloop和queue的区别 runloop和queue的区别 runloop和queue各自维护着自己的一个任务队列，在runloop的每个周期里面，会检测自身的任务队列里面是否存在待执行的task并且执行。但主线程的情况比较特殊，在main runloop的每个周期，会去检测main queue是否存在待执行任务，如果存在，那么copy到自身的任务队列中执行 async的实现不同 在非主线程之外，runloop和queue的任务队列是互不干扰的，因此两者处理任务的机制也是完全不同的。当async任务到队列时，GCD会尝试寻找一个线程来执行任务。由于串行队列同时只能与一个线程挂钩，因此GCD会让该线程执行完已有任务后，才执行async到队列中的任务。 多线程的实现有以下几种方式 线程类型 简介 语言 线程生命周期 使用频率 pthread 一套通用的多线程API 适用于Unix\Linux\Windows\OSX等系统 跨平台\可移植 使用难度大 C 程序员管理 几乎不用 NSThread 使用更加面向对象 简单易用 * 可直接操作线程对象 OC 程序员管理 偶尔使用 GCD 旨在替代NSThread等线程技术 充分利用设备的多核 C 自动管理 经常使用 NSOperation 基于GCD（底层是GCD） 比GCD多了一些更简单实用的功能 * 使用更加面向对象 OC 自动管理 经常使用 串行与并发 类型 全局并发队列 手动创建串行队列 主队列 同步(sync) 没有开启新线程 串行执行任务 没有开启新线程 串行执行任务 没有开启新线程 串行执行任务 异步(async) 有开启新线程 并发执行任务 有开启新线程 串行执行任务 没有开启新线程 串行执行任务 队列和线程 参考： 深入理解GCD 被遗弃的线程 奇怪的GCD iOS 多线程详解 玩转GCD]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS Method Swizzle的秘密]]></title>
    <url>%2F2018%2F05%2F07%2FiOS-Method-Swizzle%E7%9A%84%E7%A7%98%E5%AF%86%2F</url>
    <content type="text"><![CDATA[什么是Method Swizzling方法交换(Method Swizzling)，顾名思义就是将两个方法的实现交换，即由原来的SEL(A)－IMP(A)、SEL(B)－IMP(B)对应关系变成了SEL(A)－IMP(B)、SEL(B)－IMP(A)，如下图： Method类型Method类型是一个objc_method结构体指针，而结构体objc_method有三个成员，方法交换(Method Swizzling)的本质就是更改两个成员method_types和method_imp runtime.h源码 12345678/// An opaque type that represents a method in a class definition.typedef struct objc_method *Method; // 本质是一个结构体struct objc_method &#123; SEL method_name; // 方法名称 char *method_types; // 参数和返回类型的描述字串 IMP method_imp; // 方法的具体的实现的指针&#125; Method Swizzling 实现方式比如我们有一个控制器ParentViewController继承于UIViewController，子控制器SubViewController继承于ParentViewController。我们想替换SubViewController的viewDidAppear为swizzle_viewDidAppear, 运行后先显示ParentViewController页面，然后点击一个Button按钮，push到SubViewController页面，代码如下：（页面都是通过StoryBoard来构建的，请自行构建，我比较懒，这里就只贴上代码） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@interface ParentViewController : UIViewController@end@implementation ParentViewController- (void)viewDidAppear:(BOOL)animated&#123; NSLog(@"%@ %s (IMP = ParentViewController viewDidAppear)",self, _cmd); [super viewDidAppear:animated];&#125;@end@interface SubViewController : ParentViewController@end@implementation SubViewController+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; // 原方法名和替换方法名 SEL originalSelector = @selector(viewDidAppear:); SEL swizzledSelector = @selector(swizzle_viewDidAppear:); // 原方法结构体和替换方法结构体 Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); // 如果当前类没有原方法的实现IMP，先调用class_addMethod来给原方法添加默认的方法实现IMP BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123;// 添加方法实现IMP成功后，修改替换方法结构体内的方法实现IMP和方法类型编码TypeEncoding class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; // 添加失败，调用交互两个方法的实现 method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;- (void)swizzle_viewDidAppear:(BOOL)animated &#123; NSLog(@"%@ %s (IMP = SubViewController swizzle_viewDidAppear)",self, _cmd); [self swizzle_viewDidAppear:animated];&#125;@end 代码说明： dispatch_once 保证方法替换只被执行一次 为什么要先调用类添加方法class_addMethod，然后判断添加失败后，再调用方法交换实现方法method_exchangeImplementations？ 上面代码中SubViewController是没有Override父类的viewDidAppear。如果我们直接调用method_exchangeImplementations会怎么样？ 在这种情况下，我们试试 1234567891011121314151617+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; // 原方法名和替换方法名 SEL originalSelector = @selector(viewDidAppear:); SEL swizzledSelector = @selector(swizzle_viewDidAppear:); // 原方法结构体和替换方法结构体 Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); // 调用交互两个方法的实现 method_exchangeImplementations(originalMethod, swizzledMethod); &#125;);&#125; 改成上面的代码，然后运行。哎哟，出错了！Let me see see 什么情况 12345678910111213141516171819202122232425262728292018-05-07 21:38:56.615884+0800 TestiOS[3469:385923] &lt;ParentViewController: 0x7f8f38c09aa0&gt; viewDidAppear: (IMP = SubViewController swizzle_viewDidAppear)2018-05-07 21:38:56.616189+0800 TestiOS[3469:385923] -[ParentViewController swizzle_viewDidAppear:]: unrecognized selector sent to instance 0x7f8f38c09aa02018-05-07 21:38:56.621157+0800 TestiOS[3469:385923] *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[ParentViewController swizzle_viewDidAppear:]: unrecognized selector sent to instance 0x7f8f38c09aa0'*** First throw call stack:( 0 CoreFoundation 0x000000010e0fd1e6 __exceptionPreprocess + 294 1 libobjc.A.dylib 0x000000010d792031 objc_exception_throw + 48 2 CoreFoundation 0x000000010e17e784 -[NSObject(NSObject) doesNotRecognizeSelector:] + 132 3 UIKit 0x000000010e7a873b -[UIResponder doesNotRecognizeSelector:] + 295 4 CoreFoundation 0x000000010e07f898 ___forwarding___ + 1432 5 CoreFoundation 0x000000010e07f278 _CF_forwarding_prep_0 + 120 6 TestiOS 0x000000010ce903fb -[SubViewController swizzle_viewDidAppear:] + 75 7 UIKit 0x000000010e723ebf -[UIViewController _setViewAppearState:isAnimating:] + 697 8 UIKit 0x000000010e75ac53 -[UINavigationController viewDidAppear:] + 187 9 UIKit 0x000000010e723ebf -[UIViewController _setViewAppearState:isAnimating:] + 697 10 UIKit 0x000000010e726cfb __64-[UIViewController viewDidMoveToWindow:shouldAppearOrDisappear:]_block_invoke + 42 11 UIKit 0x000000010e72503f -[UIViewController _executeAfterAppearanceBlock] + 78 12 UIKit 0x000000010e58564f _runAfterCACommitDeferredBlocks + 634 13 UIKit 0x000000010e57477e _cleanUpAfterCAFlushAndRunDeferredBlocks + 388 14 UIKit 0x000000010e5942d7 __34-[UIApplication _firstCommitBlock]_block_invoke_2 + 155 15 CoreFoundation 0x000000010e09fb0c __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__ + 12 16 CoreFoundation 0x000000010e0842db __CFRunLoopDoBlocks + 331 17 CoreFoundation 0x000000010e083a84 __CFRunLoopRun + 1284 18 CoreFoundation 0x000000010e08330b CFRunLoopRunSpecific + 635 19 GraphicsServices 0x0000000113267a73 GSEventRunModal + 62 20 UIKit 0x000000010e57a0b7 UIApplicationMain + 159 21 TestiOS 0x000000010ce9047f main + 111 22 libdyld.dylib 0x0000000111b56955 start + 1) 控制台打印ParentViewController找不到swizzle_viewDidAppear方法。 这是为什么呢？ 第一行日志显示，ParentViewController是调用自己的方法viewDidAppear，通过打印_cmd输出为viewDidAppear可知道，但是执行的是SubViewController的swizzle_viewDidAppear的方法实现IMP，在swizzle_viewDidAppear方法实现IMP里又调用了[self swizzle_viewDidAppear:animated]这行代码，但是此时self是ParentViewController实例对象，类方法列表里根本没有swizzle_viewDidAppear方法，所以就导致找不到方法错误。说的我都觉得挺绕口的，千言万语不如一张图来的直观，向下瞅: 现在明白了吧，方法交换（Method Swizzling）在子类没有实现viewDidAppear方法的情况下会交换父类的viewDidAppear的实现IMP，所以在swizzle_viewDidAppear实现IMP中调用swizzle_viewDidAppear方法会触发doesNotRecognizeSelector找不到方法错误 如果我们的子类SubViewController重写Override了父类的viewDidAppear方法会怎么样？我们在SubViewController中重写viewDidAppear方法 123456789101112131415161718192021222324252627+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; // 原方法名和替换方法名 SEL originalSelector = @selector(viewDidAppear:); SEL swizzledSelector = @selector(swizzle_viewDidAppear:); // 原方法结构体和替换方法结构体 Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); // 调用交互两个方法的实现 method_exchangeImplementations(originalMethod, swizzledMethod); &#125;);&#125;- (void)viewDidAppear:(BOOL)animated&#123; NSLog(@"%@ %s (IMP = SubViewController viewDidAppear)",self, _cmd); [super viewDidAppear:animated];&#125;- (void)swizzle_viewDidAppear:(BOOL)animated &#123; NSLog(@"%@ %s (IMP = SubViewController swizzle_viewDidAppear)",self, _cmd); [self swizzle_viewDidAppear:animated];&#125; 改成上面的代码，然后运行。这次竟然成功了 1234562018-05-07 21:41:58.467190+0800 TestiOS[3556:400520] &lt;ParentViewController: 0x7fd5a060b730&gt; viewWillAppear2018-05-07 21:41:58.475185+0800 TestiOS[3556:400520] &lt;ParentViewController: 0x7fd5a060b730&gt; viewDidAppear: (IMP = ParentViewController viewDidAppear)2018-05-07 21:42:08.772307+0800 TestiOS[3556:400520] &lt;SubViewController: 0x7fd5a0405170&gt; viewWillAppear2018-05-07 21:42:09.312426+0800 TestiOS[3556:400520] &lt;SubViewController: 0x7fd5a0405170&gt; viewDidAppear: (IMP = SubViewController swizzle_viewDidAppear)2018-05-07 21:42:09.312643+0800 TestiOS[3556:400520] &lt;SubViewController: 0x7fd5a0405170&gt; swizzle_viewDidAppear: (IMP = SubViewController viewDidAppear)2018-05-07 21:42:09.312792+0800 TestiOS[3556:400520] &lt;SubViewController: 0x7fd5a0405170&gt; viewDidAppear: (IMP = ParentViewController viewDidAppear) 你逗我玩儿呢，怎么子类实现viewDidAppear就好了。那是因为子类在检查到自己有viewDidAppear方法就直接交换自己的viewDidAppear方法实现IMP，直接上图，我不想废话了 这下我们明白了，如果直接调用方法method_exchangeImplementations来交换方法，需要考虑到子类有没有相应的方法，如果没有就要特殊处理，那岂不是太麻烦了。哈哈😁不用你瞎操心，苹果有这个方法class_addMethod来帮助我们解决 我们把直接调用method_exchangeImplementations稍微做点修改 1234567891011121314151617181920212223242526272829+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; // 原方法名和替换方法名 SEL originalSelector = @selector(viewDidAppear:); SEL swizzledSelector = @selector(swizzle_viewDidAppear:); // 原方法结构体和替换方法结构体 Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); // 如果当前类没有原方法的实现IMP，先调用class_addMethod来给原方法添加默认的方法实现IMP BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123;// 添加方法实现IMP成功后，修改替换方法结构体内的方法实现IMP和方法类型编码TypeEncoding class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; // 添加失败，调用交互两个方法的实现 method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125; 这样我们就不用关心子类有没有实现viewDidAppear方法，方法class_addMethod在子类没有实现viewDidAppear方法的时候，为其添加swizzle_viewDidAppear方法实现IMP，原方法swizzle_viewDidAppear指向父类的viewDidAppear方法实现IMP 这就是为什么先要调用class_addMethod方法的原因了，如果子类SubViewController实现了方法viewDidAppear，那么class_addMethod方法会返回NO，意思子类存在viewDidAppear方法实现，就直接走method_exchangeImplementations方法交换 好了，就说到这里吧，有问题请留言 参考： Method Swizzling]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用加密算法探寻]]></title>
    <url>%2F2018%2F04%2F06%2F%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%8E%A2%E5%AF%BB%2F</url>
    <content type="text"><![CDATA[在开发过程中，常常用到各种加密方法和算法，本文总结了几种常用加密方法的原理。 对称加密 原理：加密和解密数据使用同一个密钥，适合对大量数据进行加解密 安全性：关键是密钥的保存方式，加密或是解密的任何一方泄漏密钥，都会导致信息泄漏 代表算法：DES、3DES、Blowfish、IDEA、RC4、RC5、RC6、AES等 对称密码常用的数学运算： 移位和循环移位 移位就是将一段数码按照规定的位数整体性地左移或右移。循环右移就是当右移时，把数码的最后的位移到数码的最前头，循环左移正相反。例如，对十进制数码12345678循环右移1位（十进制位）的结果为81234567，而循环左移1位的结果则为23456781。 置换 就是将数码中的某一位的值根据置换表的规定，用另一位代替。它不像移位操作那样整齐有序，看上去杂乱无章。这正是加密所需,被经常应用。 扩展 就是将一段数码扩展成比原来位数更长的数码。扩展方法有多种,例如,可以用置换的方法，以扩展置换表来规定扩展后的数码每一位的替代值。 压缩 就是将一段数码压缩成比原来位数更短的数码。压缩方法有多种，例如，也可以用置换的方法，以表来规定压缩后的数码每一位的替代值。 异或 这是一种二进制布尔代数运算。异或的数学符号为⊕ ，它的运算法则如下：1⊕1 = 00⊕0 = 01⊕0 = 10⊕1 = 1 也可以简单地理解为，参与异或运算的两数位如相等，则结果为0，不等则为1。 迭代 迭代就是多次重复相同的运算，这在密码算法中经常使用，以使得形成的密文更加难以破解。 非对称加密 原理：非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密 安全性：公钥可以被任何人知道，但是私钥被泄漏就会导致信息泄漏 应用场景：数字签名，私钥拥有者对信息进行加密，接受者使用公钥解密成功，就可以确定发送者的身份 密钥长度：通常是1024，2048等。密钥长度增长一倍，公钥操作所需时间增加约4倍，私钥操作所需时间增加约8倍，公私钥生成时间约增长16倍 加密的明文长度：加密的明文长度不能超过RSA密钥的长度减去11byte，比如密钥长度是1024位的，1024位=1024bit=128byte，128-11=117byte，所以明文长度不能超过117byte，如果长度超过该值将会抛出异常。加密后密文的长度为密钥的长度，如密钥长度为1024bit(128Byte)，最后生成的密文固定为 1024bit(128Byte) 代表算法：DES、3DES、Blowfish、IDEA、RC4、RC5、RC6、AES等 哈希散列算法 原理：采用某种散列函数，输入不同长度的明文，得到相同的长度的密文，明文的微小变化都能引起密文的巨大变化。其实哈希散列算法不算是真正的加密，而是生成对应明文的指纹信息，用来校验数据的完整性。 安全性：不能通过密文反推明文，通常作为数据的完整性校验 应用场景1：生成信息摘要，验证信息的完整性 应用场景2：不用明文存储用户密码，比如使用md5(md5(用户密码)+salt)来存储密码和验证密码，防止攻击者用彩虹表攻击 代表算法：MD2、MD4、MD5、PANAMA、SHA-0、SHA-1、SHA-256、SHA-512等 常用算法对比 名称 密钥长度 运算速度 安全性 资源消耗 加密类型 DES 56位 较快 低 中 对称 3DES 168位 慢 中 高 对称 IDEA 128位 较慢 中 高 对称 AES 128、192、256位 快 高 低 对称 RSA 1024、2048、3072、4096 慢 高 高 非对称 DSA 1024、2048、3072、4096 慢 高 低 非对称 ECC 256 快 高 低 非对称 SHA-1 慢 高 低 散列 MD5 快 中 低 散列 参考： DES加密算法原理 DES算法实例详解 AES对称加密算法扫盲 DES，3DES,AES这三种对称密钥的区别与联系 数字签名算法介绍和区别 HOTP和TOTP算法图解]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>加密</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
